---
title: "AI-assisted Data Cleaning Workflow"
format:
  html:
    toc: true
    toc-depth: 3
    number-sections: true
editor: visual
execute:
  eval: false
  echo: true
  warning: false
  message: false
---

# AI - Data cleaning and validation

## AI data cleaning

#### Statement to be added in methodology

“AI-assisted code generation was used for data cleaning, with all scripts reviewed and executed by the investigators.”

Always de-identify before sending to AI

#### Load and summary for AI

```{r}

library(dplyr)
library(janitor)
library(skimr)
library(jsonlite)

df <- read.csv("data.csv", stringsAsFactors = FALSE)
df <- clean_names(df)

data_summary <- list(
  structure = str(df),
  missing_pct = round(colMeans(is.na(df)) * 100, 2),
  unique_character_values = df |> 
    select(where(is.character)) |> 
    summarise(across(everything(), ~ paste(unique(.), collapse = ", "))),
  numeric_ranges = df |> 
    select(where(is.numeric)) |> 
    summarise(across(everything(), ~ paste(range(., na.rm = TRUE), collapse = "–")))
)

summary_text <- toJSON(data_summary, pretty = TRUE)

```

### Setup model and api key

#### OpenAI

```{r}

Sys.setenv(OPENAI_API_KEY = "your_api_key_here")

library(ellmer)

model <- chat_openai(
  model = "gpt-4.1-mini",
  temperature = 0.1
)

```

#### Azure OpenAI

```{r}

Sys.setenv(
  AZURE_OPENAI_API_KEY = "your_key",
  AZURE_OPENAI_ENDPOINT = "https://your-endpoint.openai.azure.com/"
)

library(ellmer)

model <- chat_azure_openai(
  deployment = "gpt-4o-mini",
  temperature = 0.1
)


```

#### Local LLM (offline, hospital-safe)

No need API for local llm

```{r}

library(ellmer)
library(ollama)

model <- chat_ollama(
  model = "llama3"
)

```

### Code to send prompt

#### Prompt setup

```{r}

ai_generate_cleaning_code <- function(summary_text, model) {

  prompt <- paste0(
"You are a public health data analyst.

INSTRUCTIONS:
- Generate ONLY executable R code
- No explanations outside code
- Do NOT load libraries
- Do NOT delete rows
- Do NOT impute values
- Do NOT change outcome definitions
- Include comments in the R code

TASKS:
- Trim whitespace in character variables
- Standardize categorical labels
- Convert variables to appropriate types
- Flag impossible numeric values
- Create missingness flags (not imputation)

DATA SUMMARY:
", summary_text
  )

  response <- chat(model, prompt)

  response$content
}


```

#### Generate the code

```{r}

cleaning_code <- ai_generate_cleaning_code(summary_text, model)

cat(cleaning_code)


```

#### Execute after Review

```{r}

eval(parse(text = cleaning_code))

```

## AI data typing + labels + reference categories

MENTION THIS IN METHODS (recommended)

*"AI-assisted code generation was used to standardize variable types, labels, and reference categories. All code was reviewed and executed by the investigators.”*

#### Load function

```{r}

ai_generate_typing_and_labels_code <- function(summary_text, model) {

  prompt <- paste0(
"You are a senior public health biostatistician and R instructor.

TASK:
Generate ONLY executable R code (no explanations outside code).

AUDIENCE:
Public health beginners (MBBS / MPH / MD Community Medicine).

REQUIREMENTS:
1. Ensure correct data types:
   - numeric → as.numeric
   - categorical → factor
2. Add VARIABLE LABELS (column descriptions)
3. Add VALUE LABELS for categorical variables
4. Explicitly set REFERENCE CATEGORIES using relevel()
5. Comment clearly why each reference category is chosen
6. Do NOT delete rows
7. Do NOT impute missing values
8. Do NOT load libraries
9. Assume dataframe name is `df`

REFERENCE CATEGORY RULES:
- Sex → reference = \"Male\"
- Binary exposure → reference = \"No\" / \"Unexposed\"
- Education → lowest level
- Socioeconomic status → lowest class
- Outcome variables → DO NOT relevel

OUTPUT:
Return ONLY R code with clear comments.

DATA SUMMARY:
", summary_text
  )

  response <- chat(model, prompt)

  response$content
}

```

#### Generate the code

```{r}

 typing_label_code <- ai_generate_typing_and_labels_code(summary_text, model)

cat(typing_label_code)

```

Execute code AFTER review

```{r}

eval(parse(text = typing_label_code))

```